[["index.html", "Data Visualization in R Using smplot Welcome! For R and ggplot2 experts Issues and Contact License", " Data Visualization in R Using smplot Seung Hyun Min 2021-11-24 Welcome! This book guides the reader to be familiar with R, a programming language, for data visualization. It also introduces the R package smplot, which aims to make the process of data visualization simple. This book was created entirely using RMarkdown for reproducibility. Note: If you are interested in recreating this figure, please read Chapter 5. For R and ggplot2 experts Please skip Chapters 1-3. Issues and Contact If you spot any mistakes in this online book, please pull-request on Github or email me seung.min@mail.mcgill.ca. If you find issues with the smplot package, please pull-request on Github. License smplot is under the MIT license. This tutorial is licensed under a Creative Commons Attribution 4.0 International License. "],["download-rstudio-basics-of-r.html", "Chapter 1 Download RStudio &amp; Basics of R 1.1 Setting up RStudio 1.2 Basics of R", " Chapter 1 Download RStudio &amp; Basics of R 1.1 Setting up RStudio Why use R for data visualization? R is free. Often, less codes are needed in R to plot an elegant graph. for/while loops (basic concepts in programming) are not necessary in R to make a production-quality graph. R is the best software for statistical analysis. Other available resources for R Stack Overflow: https://www.stackoverflow.com R for Data Science (a bible for learning R): https://r4ds.had.co.nz/ R documentation: https://www.rdocumentation.org Learn Statistics with R: https://learningstatisticswithr.com/ ggplot2 (a reference for plotting data in R): https://ggplot2-book.org/ Download requirements for RStudio Download R: http://cran.r-project.org/ For Mac users: Mac: XQuartz https://www.xquartz.org/ RStudio: http://www.rstudio.org/ Open RStudio Figure 1.1: Rstudio layout, image from http://www.sthda.com/english/wiki/running-rstudio-and-setting-up-your-working-directory-easy-r-programming Rstudio is where people do R programming. You can type codes (commands) into the console (bottom-left panel). &gt; means that the console is ready to receive more code. + means your code is not complete. You can also write (longer) codes in the script within the code editor (top-left panel). The code editor will run the script into the console. A new script can be opened by clicking: File -&gt; New -&gt; R Script. You can run a script by clicking Run\" with the green arrow or by typing ctrl + enter. It is labeled with the red circle. Or you can just type your codes directly into the console. Lets make a folder and set it as working directory Figure 1.2: Setting your working directory, image from https://www.ucl.ac.uk/~uctqiax/PUBLG100/2015/faq/setwd.html Create a folder named LearnR in Desktop. Set the folder as your working directory by clicking: Session -&gt; Set Working Directory -&gt; Choose Directory. Then find your LearnR folder. More information about setting up a directory is here: http://www.sthda.com/english/wiki/running-rstudio-and-setting-up-your-working-directory-easy-r-programming You will need set the directory every time you start RStudio. 1.2 Basics of R Lets type some codes Capitalization, punctuations and brackets are all important. ' ' and \" \" mean the same. However, ' \" are not paired. So they will not work. = and &lt;- mean equivalent. I often use &lt;-. Type ? when you are not sure about the code (ex. ?t.test) A code becomes comment when it is preceded by #. Try typing # g = 3 and see if the number gets stored in g by typing g in the console. x = 3 # x equals to 3 a &lt;- 4 # a equals to 4 d &lt;- &#39;Group&#39; # gr is equal to a character &#39;Group&#39;, which is not a number. e &lt;- &quot;Group&quot; d == e # &#39;Group&#39; and &quot;Group&quot; are equal ## [1] TRUE # g = 3 # its a comment Notice that I used == to test if d and e are equal. Therefore, == and = mean different. == tests if two things are equal. = sets two things to be equal. d == e returns TRUE because they are both 'Group'. TRUE is equivalent to 1 numerically. Now lets check if x and a are equal. x == a ## [1] FALSE It returns FALSE because x and a are not equal. This is correct because 3 and 4 are not equal. FALSE equals to 0 numerically. Below are more examples showing that TRUE = 1 and FALSE = 0. TRUE + FALSE # 1 + 0 ## [1] 1 TRUE + TRUE # 1 + 1 ## [1] 2 FALSE + FALSE # 0 + 0 ## [1] 0 TRUE*2 # 1 * 2 ## [1] 2 TRUE*FALSE # 1 * 0 ## [1] 0 How can I learn most effectively with the notes? Dont just read it. Dont just copy and paste the codes and run them in RStudio (ctrl + c &amp; ctrl + p). Make sure you type each code. You can also change your code and see if it still works. If you are not sure of your code, you can type ? before the function. If you are still not sure after reading the notes, check out Chapter 3 of R for Data Science: https://r4ds.had.co.nz/ More installation R is an old programming language. So, people, such as statisticians and programmers, have created more functions in R in the form of the package to update the language. They are free but they have to be downloaded separately. A package can contain several functions. In this tutorial, you will mainly be using ggplot2 package, which is elegant and flexible for visualizing data. Also, you will be using smplot package. It improves ggplot2 graphs visually. So, you will need to install some packages, such as ggplot2 and smplot. Please type the codes below. install.packages(&#39;tidyverse&#39;) # tidyverse was created by Hadley Wickham at RStudio, tidyverse includes ggplot2 install.packages(&#39;devtools&#39;) devtools::install_github(&#39;smin95/smplot&#39;) You only need to install them once, but you will need to reload them whenever you start a new session in RStudio using the function library(). library(tidyverse) # it has ggplot2 package ## -- Attaching packages ----------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.3 v purrr 0.3.4 ## v tibble 3.1.1 v dplyr 1.0.5 ## v tidyr 1.1.3 v stringr 1.4.0 ## v readr 1.4.0 v forcats 0.5.1 ## -- Conflicts -------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(cowplot) # it allows you to save figures in .png file library(smplot) ## Updated tutorial for smplot: smin95.github.io/dataviz/ Now lets make some graphs in the subsequent chapters. "],["basics-of-ggplot2-and-correlation-plot.html", "Chapter 2 Basics of ggplot2 and Correlation Plot 2.1 Upload sample data 2.2 Basics of ggplot2 2.3 Improve dataviz using smplot 2.4 Summary", " Chapter 2 Basics of ggplot2 and Correlation Plot Load these packages by typing the codes below. library(tidyverse) # it has ggplot2 package library(cowplot) # it allows you to save figures in .png file library(smplot) 2.1 Upload sample data Sample data: mpg I will be using an example from the book R for Data Science (https://r4ds.had.co.nz/data-visualisation.html). Question: Do cars with large engines use up more fuel than the those with small ones? Lets open mpg, which is a data frame stored in the ggplot2 package. mpg contains data about cars in the US. You can type ?mpg for more information. displ: the size of the cars engine in liters hwy: fuel efficiency. If its high, then the car uses less fuel per distance. mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto~ f 18 29 p comp~ ## 2 audi a4 1.8 1999 4 manu~ f 21 29 p comp~ ## 3 audi a4 2 2008 4 manu~ f 20 31 p comp~ ## 4 audi a4 2 2008 4 auto~ f 21 30 p comp~ ## 5 audi a4 2.8 1999 6 auto~ f 16 26 p comp~ ## 6 audi a4 2.8 1999 6 manu~ f 18 26 p comp~ ## 7 audi a4 3.1 2008 6 auto~ f 18 27 p comp~ ## 8 audi a4 qu~ 1.8 1999 4 manu~ 4 18 26 p comp~ ## 9 audi a4 qu~ 1.8 1999 4 auto~ 4 16 25 p comp~ ## 10 audi a4 qu~ 2 2008 4 manu~ 4 20 28 p comp~ ## # ... with 224 more rows Notice that some columns and rows are not shown. You can type View(mpg) to see the entire data frame. View(mpg) 2.2 Basics of ggplot2 Lets make some graphs Question: Do cars with large engines use up more fuel than the those with small ones? To answer our question, we need to plot mpg data. The x-axis should be displ, the y-axis should be hwy. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) We find that a smaller car has a higher efficiency and that a larger car has a lower efficiency. In other words, we see a negative relationship. How ggplot works When you are making a graph with ggplot2, always begin by typing the function ggplot(). The data you want to plot is the first argument here. Ex. ggplot(data = mpg). However, ggplot(data = mpg) alone does not create a graph. You will need add (by typing +) more layers, such as geom_point(). geom_point() adds points to your graphs. You will need to specify (or map) x- and y-axes in the aes() function, which means aesthetics. This process is called mapping. As you might expect, there are other geom functions, such as geom_bar(), geom_boxplot(), geom_errorbar(). They plot bar graphs, boxplots and error bars, respectively. Here is the template for using ggplot2 (copied from R for Data Science). ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) Different color of points for each unique group You can apply different colors by the class of each car (each car = each row of the mpg data frame). Include class variable in the aes() function. This maps the third variable class into your graph. aes() means aesthetic (ex. color, shape, etc). ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) You can also set different shapes for each group of the data. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class)) Or size or transparency (not recommended). But you get the idea. Using aes() in a geom function (ex. geom_point()), you can label different group of points. # different levels of transparency (alpha) for each group ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class)) # different sizes of the points for each group ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class)) Different color &amp; shape for each group You can also apply different color &amp; shape for each group of the data. Exercise: Try it on your own before you look at the code below. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class, shape = class)) Same shape across all groups So far, you have put variables such as shape and color inside the function aes(). This has enabled you to apply different shape and color for each group. If you put the variable for shape, color, size outside of aes() in the geom function, then all data points will have the specified shape, color, etc even if they are in different groups. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class), shape = 17) Notice that the color is different for each group because it is inside the function aes(). However, all the points are triangle because we have typed shape = 17 outside the function aes(). Exercise: try changing the shape of the points to the circle with the border. Figure 2.1: image from http://www.sthda.com/english/wiki/ggplot2-point-shapes Exercise: try changing the shape of the points to the circle with the border. When shape = 19, the shape is the circle without the border. When shape = 20, the shape is the small circle without the border. When shape = 21, the shape is the circle with the border. So lets set shape to 21. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class), shape = 21) Notice that the border color is different for each group, but not the color that fills the circle. Shapes without their borders (15-20) are filled with color. Shapes with the border (21-24) are filled with fill and its border colored with color. So lets change color = Class to fill = Class. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, fill = class), shape = 21) How do we draw the best-fit line of the graph? Here is our graph. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) There seems to be a negative relationship. How do we draw the best-fit line of the graphs negative relationship? Use another geom function geom_smooth(). ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; geom_point() + geom_smooth() Now lets combine geom_point() + geom_smooth() into one graph. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() acts as a system where you can add multiple geom objects, such as geom_point() and geom_smooth(). You can add multiple layers of geom in a single plot, like shown here. ggplot() and at least one geom function are necessary to draw a graph. ggplot() alone does not draw a graph. Try it on your own. ggplot(data = mpg) Writing shorter codes ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy)) Notice that we have typed mapping = aes(x = displ, y = hwy) twice. This is repetitive. If you type the mapping argument in ggplot(), you wont need to type them anymore in the subsequent geom functions. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; This is exactly the same as the previous graph. In both cases, the mapping has been set so that the x-axis is displ and the y-axis is hwy in both geom_point() and geom_smooth(). Now lets apply different color of points and the fit the line for each group. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Okay, this is extremely messy and probably a bad idea. You might have gotten warnings but you can usually ignore them. Lets plot the best-fit line across all groups (i.e., one best-fit line) but apply different color for each class (i.e., many colors). To do so, type color = class in geom_point, not ggplot(). This enables you to specify that you will apply different color for each class only in geom_point() but not in geom_smooth(). ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 2.3 Improve dataviz using smplot Although the default theme of ggplot2 graphs is clean, there are some things that I do not like: The fonts are too small. The grey background is distracting. There are too many grids. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() Lets make this graph prettier by using functions from smplot. In this example, lets use sm_corr_theme(). Ive made this function as a theme suitable for correlation plots. Disclaimer: smplot package has been built based on my preference. smplot is not necessary to make a ggplot graph or change its style. It is possible to change every aspect of the graph with ggplot2 but this requires about 8-20 lines of codes (based on my experience). Instead, smplot function does so in one line of code. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + sm_corr_theme() Now lets remove the border within sm_corr_theme() by setting borders = FALSE. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + sm_corr_theme(borders = FALSE) Exercise: You can also set borders = TRUE and see what happens. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + sm_corr_theme(borders = TRUE) You might notice that borders come back. This is exactly what happens when you do not include borders argument in sm_corr_theme(). This is because sm_corr_theme() is set to borders = TRUE as default. I think the one with the border looks better. You can also remove the legend by setting legends = FALSE in sm_corr_theme(). ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + sm_corr_theme(legends = FALSE) Exercise Set legends = TRUE and see what happens. Type ?sm_corr_theme to see why legends appear without directly writing legends = TRUE. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + sm_corr_theme(legends = TRUE) However, in this case, I think we need a legend because there are many classes. Positive relationship between x- and y-axes Lets plot another scatterplot using mtcars data. Set the x-axis with drat and y-axis with mpg. Since you are making a scatterplot, you will need to use geom_point(). Set the size of all points to 3 by typing size = 3. Set the shape of all points to the circle with a border by typing shape = 21. Set the filled color of all points to green by typing fill = '#0f993d'. Set the border color to white by typing color = 'white'. Since shape = 21 refers to the circle with a border, fill is the color that fills the points and color is the border color. ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) drat and mpg have a positive relationship. Now lets make it pretty by adding sm_corr_theme(). ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme() You can remove borders too by setting borders = FALSE in sm_corr_theme(). ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme(borders = FALSE) Reporting statistics from a paired correlation smplot also offers a function that plots the best-fit line of a scatterplot (i.e., correlation plot) and prints statistical values, such as p- and R-values. p-value is used to check for statistical significance. If its less than 0.05, its regarded as statistically significant. However, it gets smaller with a larger sample size. R-value (correlation coefficient) measures the strength and the direction of the correlation. It ranges from -1 to 1. It does not depend on the sample size. Lets add a function sm_statCorr(). The statistical results are from Pearsons correlation test. ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme() + sm_statCorr() ## `geom_smooth()` using formula &#39;y ~ x&#39; I dont really like how the line color is different from that of the points. Lets change the color to green. Also lets get results from Spearmans correlation test rather than from Pearsons. To do so, type corr_method = 'spearman' in the function sm_statCorr(). You will get a different R value from 0.68, which is from Pearsons correlation test. ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme() + sm_statCorr(color = &#39;#0f993d&#39;, corr_method = &#39;spearman&#39;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Exercise: Set corr_method = 'pearson'and see what happens. ggplot(data = mtcars, aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;#0f993d&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme() + sm_statCorr(color = &#39;#0f993d&#39;, corr_method = &#39;pearson&#39;) You will see that this is exactly the same as when corr_method argument is not included in sm_statCorr(). In short, the default correlation method for sm_statCorr() is 'pearson'. So, if you dont write anything for corr_method, it will give results from Pearsons correlation test. Type ?sm_statCorr to see the default of line_type. #0f993d is a specific green that I like. Now, lets change the color. Replace '#0f993d' with 'green' in geom_point() and sm_statCorr. This 'green' is the default green color of R. ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = &#39;green&#39;, color = &#39;white&#39;, size = 3) + sm_corr_theme() + sm_statCorr(color = &#39;green&#39;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Which one do you prefer? fill = '#0f993d' vs fill = 'green' I personally like #0f993d more. However, R does not recognize this color as green. So how are you supposed to remember the color code? You do not have to. You can type sm_color('green') instead. This is a function from the smplot package. sm_color() accepts the name of the color. If you want to get the hex codes (color codes) for red and green, type sm_color('red','green'). sm_color(&#39;red&#39;,&#39;green&#39;) Again, sm_color() has been built based on my preference. So it returns the hex codes of colors that I use most often. There are many more color themes that are available in R. For more information, please check out Chapter 28 of R for Data Science (https://r4ds.had.co.nz/graphics-for-communication.html). ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;,size = 3) + sm_corr_theme() + sm_statCorr(color = sm_color(&#39;green&#39;)) ## `geom_smooth()` using formula &#39;y ~ x&#39; Exercise Change the color of the points and the best-fit line to blue using sm_color(). If you want to see all the color options for sm_color(), type ?sm_color. There are 16 colors total. ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;blue&#39;), color = &#39;white&#39;,size = 3) + sm_corr_theme() + sm_statCorr(color = sm_color(&#39;blue&#39;)) Different color for each group but with other colors Lets go back to the mpg data. Set the x-axis with displ and y-axis with hwy. Then make a scatterplot using geom_point(). Set the size of the points to 2 across all groups. So type size = 2 outside of aes() in geom_point(). Lets apply different color for each class of the cars by writing color = class in aes() from ggplot(). fill = class is needed when the shape of the point is set to 21-25. ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point(size = 2) To use other colors, we could use a function from ggplot2 called scale_color_manual(). scale_fill_manual() is used when the shape of the point has borders (shape = 21-25). To find how many colors we need total, we need to find how many groups exist. unique_classes &lt;- unique(mpg$class) In R, you can extract data from one column by using $. You can try it with different variables too. unique() returns unique values in the selected data. Then compute the number of unique values using length() function. number_of_classes &lt;- length(unique_classes) number_of_classes ## [1] 7 sm_palette accepts the number of colors as input. It returns colors that I use most often. Now that we know we need 7 colors total, we can type sm_palette(7) or sm_palette(number_of_classes) for values in scale_color_manual(). ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point(size = 2) + scale_color_manual(values = sm_palette(number_of_classes)) + sm_corr_theme() Lets store this graph using a variable called figure1. figure1 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point() + scale_color_manual(values = sm_palette(number_of_classes)) + sm_corr_theme() ggplot(data = mpg) # make your graph disappear figure1 # it will appear again by calling this variable Now you will able to call forth the graph just by calling the figure1 variable in the console. Lets save the plot as an image in your folder LearnR by using the variable figure1. To save the figure as an image, we will use a function from the cowplot package. The function is save_plot(). There is one important argument: base_asp. This is the ratio of your image (width/height). I usually set it to 1.4. So lets type base_asp = 1.4 in save_plot(). If base_asp is larger than 1, it gets wider than its height. This is recommended when you have a legend. If there is no legend, then base_asp = 1 is recommended. save_plot(&#39;figure1.png&#39;, figure1, base_asp = 1.4) Exercise: try to save it again with a name figure1b.png by typing: save_plot(&#39;figure1b.png&#39;, figure1) Hows the picture? Why does it look different? Type ?save_plot to see what the default base_asp is. Done! The graph (in png file) should be in your LearnR folder. Exercise: Try to open Microsoft Word or PowerPoint and upload figure1. The figure should look the same as it appears in the slides. Exercise: Remove the legend and save the scatterplot with base_asp = 1. Congratulations! You can now make correlation plots with R. 2.4 Summary You have learned the basics of ggplot. You begin by writing a ggplot() function. If aesthetics (color, shape, etc) are specified outside of aes() function, then there is no group difference. If aesthetics are specified in aes(), different groups of data will have different looks. You have learned to add geom layers such as geom_point(), which shows points, and geom_smooth(), which plots the best-fit function. You have learned to plot geom_point() and geom_smooth() in the same graph. smplot functions can be used to improve ggplot2 visually. For correlation plots, add sm_corr_theme(). You can report statistical results and plot linear regression from correlation by sm_statCorr(). You can also select colors using sm_color(). Save the graph as an image file in your working directory. Working directory has to be set in RStudio (Session -&gt; Set Working Directory -&gt; Choose Directory) Then use save_plot() from cowplot to save the image in your directory (folder LearnR). "],["boxplot-and-violin-plot.html", "Chapter 3 Boxplot and Violin Plot 3.1 Upload sample data (csv file) in RStudio 3.2 Boxplot 3.3 Violin plot 3.4 Summary", " Chapter 3 Boxplot and Violin Plot Load these packages by typing the codes below. library(tidyverse) # it has ggplot2 package library(cowplot) # it allows you to save figures in .png file library(smplot) 3.1 Upload sample data (csv file) in RStudio Download requirements Download data.csv from https://raw.githubusercontent.com/smin95/dataviz/master/data.csv Put the file data.csv in your LearnR folder Before we get started Set LearnR folder as your working directory by by clicking: Session -&gt; Set Working Directory -&gt; Choose Directory. Then find your LearnR folder. Load these three packages with the library() function: ggplot2, cowplot and smplot. Since the tidyverse package includes the ggplot2 package, you can load tidyverse instead. tidyverse has other packages beside ggplot2, so it is more useful. Remember from the last tutorial that: Functions from the ggplot2 package include ggplot() and other geom functions such as geom_point(), geom_smooth(), etc. Functions from the smplot package improve the ggplot2 graphs visually. However, they are not required to make a graph using ggplot2. The cowplot package has a function called save_plot, which is very useful for saving a graph as an image. data.csv Lets load data.csv in R from your LearnR folder. Then store the loaded data into a variable called df. We will use a function from the tidyverse package called read_csv(). For more information, type ?read_csv(). df &lt;- read_csv(&#39;data.csv&#39;) ## ## -- Column specification ---------------------------------------------------- ## cols( ## Subject = col_character(), ## Value = col_double(), ## Day = col_character() ## ) If you get an error such as object 'data.csv' not found, make sure you set your working directory in the LearnR folder. Also make sure you have downloaded your data and saved it in the LearnR folder. You can view the entire data frame by typing View(df). View(df) There are three columns in df. The first column (Subject) is the subject number. S1 means the first subject, and S2 second. The second column (Value) is the data. It contains numbers. The third column (Day) is the day of testing. There are three days of measurement: One, Two and Three. What is the data about? 30 patients were tested across three days to see if there was an improvement in their visual function (Value). The higher value, the better the vision. Day One: first day of the study. This is the baseline value. After this measurement, patients received treatment (ex. drug, surgery, etc). Day Two: second day of the study. This is the one day after receiving the treatment. Day Three: third day of the study. This is two days after receiving the treatment. The data are all fake. read_csv('data.csv') Lets use the variable df to store the output from data.csv. df is shortened from data frame, which refers to a structure of the data that is commonly used for data analysis. In fact, data.csv has the structure of a typical data frame. Each column is a variable. Each row represents an observation In future, I suggest you save data that has a similar structure to that of df. Put your own data in Microsoft Excel and save it as a csv file to load it on R. Exercise: Open data.csv using Microsoft Excel. Change the name of third column into Group. Then, save it as data2.csv. What does this data frame indicate now? It indicates there are 30 individuals for each group. Also, there are 3 groups, so there are 90 individuals total. So, it might be better to change the subject number so each person has a unique label, such as S1 to S90. Best way to plot data A popular way to visualize data is plotting a bar graph. However, a bar graph does not show the distribution of the data well. For this reason, boxplot and violin plots have become more popular in scientific writing. 3.2 Boxplot What is a boxplot? This is the basic structure of the boxplot. The line in the middle is the median of the data. The first quartile is the lower 25% of the data. The third quartile is the 75% percentile of the data. The interquartile range is the distance between the first and third quartiles. The lower whisker is the lowest data point without outliers. The upper whisker is the highest data point without outliers. The point that lies outside the whisker is the outlier. Boxplot vs bar graph Here is the basic structure of the bar graph. The boxplot is more informative than bar graph. The bar graph only shows the mean (average) of the data and the standard error. The bar graph does not represent the distribution very well. The narrow errorbar is quite misleading here. For this reason, lets focus on drawing a boxplot. Boxplot using ggplot2 We want to plot Value (y-axis) from each Day (x-axis). As always in ggplot, lets start by writing ggplot(). Make sure you specify the data to plot by writing data = df in ggplot(). Also, you will need to specify the x- and y-axes in the mapping argument within ggplot(). x = Day and y = Value. ggplot(data = df, mapping = aes(x = Day, y = Value)) However, as we learned in the last lesson, ggplot requires geom objects to plot something. Last time we used geom_point(), which plots points. Now, lets use geom_boxplot() to plot a boxplot. ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_boxplot() Heres the boxplot! But I think there is a problem here. Day Three precedes Day Two in the x-axis. Exercise: Why do you think Three appeared first? Problem: Alphabetical order The issue with the boxplot is that the x-axis followed an alphabetical order. Th precedes Tw. In short, R does not seem to know that we want the order to be One -&gt; Two -&gt; Three. R decided to follow the alphabetical order is because the column Day is shown as &lt;chr&gt;, which means character. df ## # A tibble: 90 x 3 ## Subject Value Day ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 S1 -0.752 One ## 2 S2 0.220 One ## 3 S3 -1.00 One ## 4 S4 1.91 One ## 5 S5 0.395 One ## 6 S6 -0.985 One ## 7 S7 0.585 One ## 8 S8 0.886 One ## 9 S9 0.691 One ## 10 S10 -0.366 One ## # ... with 80 more rows Note that the Subject column is also considered as &lt;chr&gt; (characters) because it contains texts/alphabets. The Value column is categorized as &lt;dbl&gt;, which means double. Double basically means numbers. In R, character is also referred to as string. They mean the same thing. Here are more examples of characters/strings. a &lt;- &#39;R is very useful!&#39; b &lt;- &#39;Dogs are so cute.&#39; c &lt;- &#39;Clarinet is the best.&#39; In these examples, you have stored the characters/strings in the variables a, b and c. Displaying characters in a non-alphabetical order Factors are important when you want to display characters in non-alphabetical order. Factors are variables that have a limited number of different values. For example, if a dataset has two groups (controls and patients), these can be referred to as factors. However, when you are using read_csv() to load data into RStudio, read_csv() will interpret texts/alphabets as characters, not factors. This is a problem when you need a non-alphabetical order, such as one -&gt; two -&gt; three and Jan -&gt; Feb -&gt; Mar -&gt; Apr. To resolve this problem, you will need to change the characters into factors using factor() function. df$Day &lt;- factor(df$Day, levels = c(&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;)) Remember that &lt;- means equivalent. Also, $ of a data frame can extract a specific column You can also type df$Value and run it to see what happens. You will get all values of the second column Value. df$Value By using factor(), you are making the Day column of df into factor from character. However, you will need to store the factored version of df$Day by using &lt;-. If not, df$Day will stay as character. levels argument in factor() allows you to specify the order of the factors. For more information about factors, please check Chapter 15 of R for Data Science (https://r4ds.had.co.nz/factors.html). Note: you do not have to understand this part 100%. However, if you do encounter similar issues, I suggest you resolve it with the solution above. Double-check if the Day column is factor Lets open the data frame df again. df ## # A tibble: 90 x 3 ## Subject Value Day ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 S1 -0.752 One ## 2 S2 0.220 One ## 3 S3 -1.00 One ## 4 S4 1.91 One ## 5 S5 0.395 One ## 6 S6 -0.985 One ## 7 S7 0.585 One ## 8 S8 0.886 One ## 9 S9 0.691 One ## 10 S10 -0.366 One ## # ... with 80 more rows Now we see &lt;fct&gt; in the Day column. This means that the column is now factor, not character. Back to boxplot using ggplot2 Now lets draw the boxplot again. ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_boxplot() Since we have converted the Day column of df into factor, the boxplot successfully plots each day in the correct order. A boxplot with individual data Sometimes, it is preferable to plot individual data on top of the boxplot. There are many ways to do this. Here is a simple solution by using geom_jitter(). For more information, type ?geom_jitter. ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_boxplot() + geom_jitter() I think the points are too spread. So lets set the width of the spread in geom_jitter() to 0.15. Also, lets apply a different color of points for each Day. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_boxplot() + geom_jitter(width = 0.15) Now we can make the boxplot prettier with sm_minimal(), which removes all grids in the graph. We can also set legends = FALSE to remove the legends. Lets also add a title Visual improvement after treatment using ggtitle(), which is a function from the ggplot2 package. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_boxplot() + geom_jitter(width = 0.15) + sm_minimal(legends = FALSE) + ggtitle(&#39;Visual improvement after treatment&#39;) Now lets set the colors using sm_palette(). Remember from the last lesson that we set the colors in ggplot by using scale_color_manual() for points without borders. Lets write 3 in sm_palette() because we need 3 colors (for each Day). ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_boxplot() + geom_jitter(width = 0.15) + sm_minimal(legends = FALSE) + ggtitle(&#39;Visual improvement after treatment&#39;) + scale_color_manual(values = sm_palette(3)) If you need horizontal grids, you can simply replace sm_minimal() with sm_hgrid(). There is also sm_vgrid() but I will not try it here because it is not so useful in our context. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_boxplot() + geom_jitter(width = 0.15) + sm_hgrid(legends = FALSE) + ggtitle(&#39;Visual improvement after treatment&#39;) + scale_color_manual(values = sm_palette(3)) geom_boxplot() vs sm_boxplot() geom_boxplot() does not show individual data. You need to add geom_jitter(). sm_boxplot() shows both a boxplot and individual data. It automatically uses sm_hgrid(). ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_boxplot() + ggtitle(&#39;Visual improvement after treatment&#39;) + scale_color_manual(values = sm_palette(3)) Lets keep the color of the boxplot the same across Day. So we should remove color = Day in aes(). However, since the shape is 16 (circle without borders), this will cause the points across Day to have the same color too. So lets change the shape of the points to 21, which is a circle with borders. So fill decides the filling color now. Lets set fill = Day in aes(). Also, color here only affects the border color. Lets set it to white. Make sure you change scale_color_manual() to scale_fill_manual(). ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(shape = 21, color = &#39;white&#39;) + ggtitle(&#39;Visual improvement after treatment&#39;) + scale_fill_manual(values = sm_palette(3)) Now, pick your favorite boxplot and store it in a variable called my_boxplot using &lt;-. my_boxplot &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(shape = 21, color = &#39;white&#39;) + ggtitle(&#39;Visual improvement after treatment&#39;) + scale_fill_manual(values = sm_palette(3)) Save boxplot We can save the boxplot by using save_plot() from the cowplot package. Lets set the aspect ratio (width/height) to 1. So, type base_asp = 1. save_plot(&#39;boxplot.jpg&#39;, my_boxplot, base_asp = 1) This image file should now be in your LearnR folder. 3.3 Violin plot The boxplot represents the distribution quite well but it can still be misleading. Also, it can be visually overwhelming (i.e., too crowded) to some readers. So, researchers have begun favoring the violin plot more. Structure of the violin plot The part in the middle is the widest because it has most points. This part has the highest point density. The lower and upper ends of the violin plot are thinner because there are less points. Lets draw a violin plot in R. Violin plot with ggplot2 Lets draw the violin plot. Specify the x-axis to Day and the y-axis to Value using data frame df. ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_violin() Notice that since we have already converted the Day column of df into factor, the violin plots x-axis is in the correct order. Also, notice that we can just replace geom_boxplot() with geom_violin(). Violin plot with individual points Lets add individual points to the violin plot by using geom_jitter(). Set width of the spread to 0.15. ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_violin() + geom_jitter(width = 0.15) Now lets apply different color to each Day like we did in boxplot by using scale_color_manual(). Lets use sm_palette(3). ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_violin() + geom_jitter(width = 0.15) + scale_color_manual(values = sm_palette(3)) Finally, lets make it pretty and remove the legend by applying sm_hgrid() theme, which only has horizontal grids. Lets also add a title Visual improvement after treatment using ggtitle(). ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_violin() + geom_jitter(width = 0.15) + scale_color_manual(values = sm_palette(3)) + sm_hgrid() + ggtitle(&#39;Visual improvement after treatment&#39;) geom_violin() vs sm_violin() geom_violin() does not show individual data. You need to add geom_jitter(). sm_violin() shows both a boxplot and individual data. It automatically uses sm_hgrid(). It also display lines that represent the mean and +/- standard deviation. In sm_violin(), the default shape ('point_shape') is 16, which is the circle without borders. Lets try using sm_violin(). color here filling color of the jittered points. Also, color affects the color of the lines that show the mean and +/- standard deviation. Lets set color = Day in aes() so that we can apply different colors of the lines and the points for each group. Make sure you have scale_color_manual(). ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;Visual improvement after treatment&#39;) Save your violin plot Pick your violin plot and store it in a variable called my_violin using &lt;-. my_violin &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;Visual improvement after treatment&#39;) We can save the violin plot by using save_plot() from the cowplot package. Lets set the aspect ratio (width/height) to 1. So, type base_asp = 1. save_plot(&#39;violin.jpg&#39;, my_violin, base_asp = 1) This image file should now be in your LearnR folder. 3.4 Summary You have learned how to convert characters to factors. Factor is important to order words/letters in a non-alphabetical order. You can now make a boxplot and a violin plot with R. They are more informative than a bar graph. You have learned to use geom functions, such geom_boxplot(), geom_violin(), and geom_jitter(). These are functions from the ggplot2 package. You can also plot individual data at the same time with functions from the smplot package. These functions are sm_boxplot() and sm_violin(). "],["full-guide-on-smplot.html", "Chapter 4 Full Guide on smplot 4.1 Installation of the package 4.2 smplots color palette and graph themes 4.3 Correlation plot 4.4 Boxplot - sm_boxplot() 4.5 Violin plot - sm_violin() 4.6 Bar plot - sm_bar() 4.7 Slope chart - sm_slope() 4.8 A Bland Altman plot - sm_bland_altman() 4.9 Raincloud plot - sm_raincloud() 4.10 Overriding defaults of smplots themes", " Chapter 4 Full Guide on smplot This chapter is for those who know how to use ggplot2 already and skipped Chapters 1-3 from the online tutorial. It also includes tutorials about sm_bar(), sm_bland_altman() and sm_raincloud(), all of which are not mentioned in the preceding chapters. 4.1 Installation of the package The smplot package is NOT available on CRAN yet. So, you will need to download it directly from my github for now. To install it, please type in the R console: install.packages(&#39;devtools&#39;) devtools::install_github(&#39;smin95/smplot&#39;) To use the package, load it: library(smplot) What is smplot? smplot is a package that provides functions that visually improve graphs produced from ggplot2. So it does not work with plots made from base R. It was first developed in May 2021. It is free and open source (https://github.com/smin95/smplot). 4.2 smplots color palette and graph themes smplots color palette Its color palette can be accessed via two functions: sm_color() and sm_palette(). sm_color() accepts the character string of the color name. sm_palette() accepts the number of colors (up to 16) and returns the hex codes accordingly. Figure 4.1: smplots color palette For example, if you want blue and red, just type the input like this: sm_color(&#39;blue&#39;,&#39;red&#39;) ## [1] &quot;#1262b3&quot; &quot;#cc3d3d&quot; But, do not form a single vector that contains two characters. If so, sm_color() will only return the first color. sm_color(c(&#39;blue&#39;,&#39;red&#39;)) ## Warning in if (color == &quot;blue&quot;) return(&quot;#1262b3&quot;): the condition has length ## &gt; 1 and only the first element will be used ## [1] &quot;#1262b3&quot; If you need 5 colors, you can use sm_palette(). sm_palette(5) ## [1] &quot;#cc1489&quot; &quot;#1262b3&quot; &quot;#5b4080&quot; &quot;#e57717&quot; &quot;#0f993d&quot; smplots graph themes There are several its graph themes. The text positions and the font are all similar. sm_corr_theme() and sm_hvgrid() are equivalent. They have major horizontal and vertical grids. This theme is useful for correlation, so I created a duplicate function sm_corr_theme(). sm_bar_theme() and sm_hgrid() are equivalent. They have major horizontal grids. This theme is useful for a bar graph, so I created a duplicate function sm_bar_theme(). sm_minimal has no major grid. This is useful when a graph has a lot of annotation, such as texts and arrows. sm_slope_theme() is a theme for a slope chart. It removes everything except the y-axis. All of these functions, except for sm_slope_theme(), have two arguments: borders and legends. For some of these functions, the defaults are set to borders = TRUE and legends = TRUE. You can check the defaults by typing ? in front of the function. Ex: ?sm_corr_theme There is no option for borders in sm_slope_theme(). p1 has the default theme of ggplot2. library(tidyverse) p1 &lt;- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + geom_point(size = 2) p1 Now we can change the theme using sm_corr_theme(). p1 + sm_corr_theme() We can also remove borders and legends by setting them as FALSE. p2 &lt;- p1 + sm_corr_theme(borders = FALSE, legends = FALSE) p2 You can also apply smplots colors by using scale_color_manual(). p2 + scale_color_manual(values = sm_palette(7)) 4.3 Correlation plot sm_corr_theme() and sm_statCorr() can be used as a pair when plotting a correlation. This is the plot using the default theme of ggplot2. p1 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;, size = 3) p1 The next plot uses sm_corr_theme() to apply the smplots theme and sm_statCorr() to print linear regression slope and statistical results from a paired correlation test (Pearsons). Important: sm_statCorr() recognizes the data for the y- and x-axes from the mapping = aes() in ggplot() function. There is no mapping argument in sm_statCorr(). p1 + sm_corr_theme() + sm_statCorr(color = sm_color(&#39;green&#39;)) You can also change the line_type to 'solid' in sm_statCorr(), and change the location of the printed texts by using label_x and label_y arguments. You can also change the font size of the printed texts by setting text_size to a larger numerical value. p1 + sm_corr_theme() + sm_statCorr(color = sm_color(&#39;green&#39;), line_type = &#39;solid&#39;, label_x = 3.5, label_y = 30, text_size = 5) 4.4 Boxplot - sm_boxplot() sm_boxplot() generates a boxplot and individual points at the same time. It automatically uses sm_hgrid() as its default theme. First, lets generate some random data. set.seed(1) # generate random data day1 = rnorm(16,0,1) day2 = rnorm(16,5,1) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:16)), 2) Data &lt;- data.frame(Value = matrix(c(day1,day2),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;), each = length(day1)) df &lt;- cbind(Subject, Data, Day) Now, lets make a boxplot using sm_boxplot(). # a boxplot with the random data, all black points ggplot(data = df, mapping = aes(x = Day, y = Value)) + sm_boxplot(fill = &#39;black&#39;) Now lets apply different color for each Day. # a boxplot with different colored points ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(shape = 21, color = &#39;white&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) You can change the shape of the boxplot by setting notch = TRUE. You can also change the size of the individual points using point_size argument. A notched boxplot shows the confidence interval around the median (+/- 1.58 * interquartile range / sqrt(n)). The notches are used for group comparison. If the notch of each box does not overlap, there is a strong likelihood that the medians are significantly different between groups. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(shape = 21, point_size = 4, notch = &#39;TRUE&#39;, alpha = 0.5) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) 4.4.1 Plotting individual points with unique colors One can also use sm_boxplot() to plot individual points with unique colors. But sm_boxplot() cannot print distinct box colors across distinct x levels (i.e., in this example, all boxes are grey). This is because the author thinks it is not a good practice to print different colors of boxes as they tend to distract the reader. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Subject)) + sm_boxplot(shape = 21, color = &#39;white&#39;) + scale_fill_manual(values = sm_palette(16)) 4.5 Violin plot - sm_violin() sm_violin() plots a violin plot, individual points and lines that indiciate means and +/- 1 standard deviation at the same time. It is very similar to sm_boxplot() except there is no option for notch = TRUE in sm_violin(). Also sm_violin() uses both color (for the lines of mean and SD) and fill (for the colors of the points) arguments. The default border color of the points is white. sm_violin() automatically uses sm_hgrid() as its default theme. # a violin plot with the random data, all black points and lines ggplot(data = df, mapping = aes(x = Day, y = Value)) + sm_violin(fill = &#39;black&#39;) # a violin plot with different colored points and lines ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) 4.5.1 Plotting individual points with unique colors One can also use sm_violin() to plot individual points with unique colors. The x-level has to be grouped in the aesthetics (ex. group = Day). But sm_violin() cannot print distinct violin colors across distinct x levels (i.e., in this example, all boxes are grey). This is because the author thinks it is not a good practice to print different colors of boxes as they tend to distract the reader. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Subject, group = Day)) + sm_violin(shape = 21, color = &#39;white&#39;, point_alpha = 0.6) + scale_fill_manual(values = sm_palette(16)) ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Subject, group = Day, color = Day)) + sm_violin(shape = 21, color = &#39;white&#39;, point_alpha = 0.6) + scale_fill_manual(values = sm_palette(16)) + scale_color_manual(values = sm_color(&#39;blue&#39;, &#39;orange&#39;)) 4.6 Bar plot - sm_bar() It automatically uses sm_bar_theme() / sm_hgrid(). Lets use data (df) we generated before. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) In this case, the error bar represents standard error. If you prefer to show standard deviation, then you should set se = FALSE in sm_bar(). ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;, se = FALSE) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) 4.6.1 Plotting individual points with unique colors One can also use sm_bar() to plot individual points with unique colors. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Subject)) + sm_bar(bar_fill_color = &#39;gray80&#39;) + scale_color_manual(values = sm_palette(16)) sm_bar() can also print distinct box colors across distinct x levels. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Subject, fill = Day)) + sm_bar() + scale_color_manual(values = sm_palette(16)) + scale_fill_manual(values = sm_color(&#39;lightorange&#39;,&#39;skyblue&#39;)) 4.7 Slope chart - sm_slope() This function plots a slope chart. A slope chart is useful to describe changes between two different timepoints for each measurement (ex. a participant). It automatically uses sm_slope_theme(). Lets use df that we generated before. Important: To make this function work, the mapping within ggplot() has to have a certain structure. x- and y-axes have to be defined. A slope chart groups each observation (ex. Subject) across x-axis. This has to be specified in mapping as group =. The x-axis cannot be continuous. It has to be discrete. So, it should take the form of character or factor (ex. One, Two, Three). If x-axis only has number (i.e., double form, such as 1.02, 1.05, 1.5), then sm_slope() will produce an error. labels argument is required to use sm_slope(). This refers to the labels of the ticks in the x-axis. Ex. labels = c('Day 1', 'Day 2'). ggplot(data = df, mapping = aes(x = Day, y = Value, group = Subject)) + sm_slope(labels = c(&#39;Day 1&#39;, &#39;Day 2&#39;)) Lets set the shape to 21. Lets make the border color to white. Lets apply the same color to each Day. ggplot(data = df, mapping = aes(x = Day, y = Value, group = Subject)) + sm_slope(labels = c(&#39;Day 1&#39;,&#39;Day 2&#39;), shape = 21, color = &#39;white&#39;, fill = sm_color(&#39;blue&#39;)) You could also apply different color for each Day using scale_fill_manual(). ggplot(data = df, mapping = aes(x = Day, y = Value, group = Subject, fill = Day)) + sm_slope(labels = c(&#39;Day 1&#39;,&#39;Day 2&#39;), shape = 21, color = &#39;white&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) 4.8 A Bland Altman plot - sm_bland_altman() sm_bland_altman() and sm_statBlandAlt() functions can be used to create a Bland-Altman plot. The plot is used to measure agreement between two different measurements. It is also used to measure test-retest variability of a method. Lets generate random data. set.seed(1) first &lt;- rnorm(20) second &lt;- rnorm(20) df3 &lt;- as_tibble(cbind(first,second)) # requires library(tidyverse) Now lets draw a Bland Altman plot using sm_bland_altman(), which requires two arguments: first dataset, second dataset. They have to be numerical vectors of equal length. This function automatically uses sm_classic() theme. sm_bland_altman(df3$first, df3$second, color = sm_color(&#39;green&#39;)) + scale_y_continuous(limits = c(-4,4)) The upper dashed line represents the upper limit of the difference between two measurements (mean difference + 1.96 * standard deviation of the difference). The upper dashed line represents the upper limit of the difference between two measurements (mean difference - 1.96 * standard deviation of the difference). The middle dashed line represents the mean difference. The shaded region is the 95% confidence interval of the difference between the two measuremnts from one-sample t-test (difference vs 0). If the shaded region includes 0 in the y-axis, then there is no significant difference (p &gt; 0.05) between 0 and the difference. If it does not include 0, then there is a significant difference. This indicates that the two measurement results are considerably different. I usually label them with annotate(), which is a function from ggplot2. This process can be tedious. Also, sm_statBlandAlt() calculates the statistical values that are necessary to draw a Bland-Altman plot, such as the mean difference, upper and lower limits. This function is used to annotate the values in the plot. The arguments for this function are first and second datasets, just like in sm_bland_altman(). res &lt;- sm_statBlandAlt(df3$first,df3$second) # store the results in res variable sm_bland_altman(df3$first, df3$second, color = sm_color(&#39;green&#39;)) + scale_y_continuous(limits = c(-4,4)) + annotate(&#39;text&#39;, label = &#39;Mean&#39;, x = -1, y = res$mean_diff + 0.4) + annotate(&#39;text&#39;, label = signif(res$mean_diff,3), x = -1, y = res$mean_diff - 0.4) + annotate(&#39;text&#39;, label = &#39;Upper limit&#39;, x = 1.2, y = res$upper_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$upper_limit,3), x = 1.2, y = res$upper_limit - 0.4) + annotate(&#39;text&#39;, label = &#39;Lower limit&#39;, x = 1.2, y = res$lower_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$lower_limit,3), x = 1.2, y = res$lower_limit-0.4) Lets change the border color of the circles to white. To do so, we will have to change their shape to 21. sm_bland_altman(df3$first, df3$second, shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;) + scale_y_continuous(limits = c(-4,4)) + annotate(&#39;text&#39;, label = &#39;Mean&#39;, x = -1, y = res$mean_diff + 0.4) + annotate(&#39;text&#39;, label = signif(res$mean_diff,3), x = -1, y = res$mean_diff - 0.4) + annotate(&#39;text&#39;, label = &#39;Upper limit&#39;, x = 1.2, y = res$upper_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$upper_limit,3), x = 1.2, y = res$upper_limit - 0.4) + annotate(&#39;text&#39;, label = &#39;Lower limit&#39;, x = 1.2, y = res$lower_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$lower_limit,3), x = 1.2, y = res$lower_limit-0.4) 4.9 Raincloud plot - sm_raincloud() A raincloud plot is a combination of jittered points, a boxplot and a violin plot. However, this plot can be visually crowded. Some people like to use raincloud plots, some do not. So, the choice to use it is entirely yours. Lets generate some random data. set.seed(2) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) day3 = rnorm(20,6,1.5) day4 = rnorm(20,7,2) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 4) Data &lt;- data.frame(Value = matrix(c(day1,day2,day3,day4),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;, &#39;Day 3&#39;, &#39;Day 4&#39;), each = length(day1)) df2 &lt;- cbind(Subject, Data, Day) The x-axis variable column has to have the right level. If not, you should convert the column as factor and establish the levels correctly. Now lets draw a raincloud plot using sm_raincloud(). sm_raincloud(data = df2, x = Day, y = Value) Lets change the x-axis labels. sm_raincloud(data = df2, x = Day, y = Value) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) The filling colors of the violin plots and boxplots can be modified by using scale_fill_manual(). The border color of the violin plot can be changed by using scale_color_manual(). I will set it transparent to remove the border of the violin plots. The color of the points can be used by either of the 2 functions depending on the shape, which can be set within sm_raincloud(). sm_raincloud(data = df2, x = Day, y = Value, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) Since this dataset is a repeated measures (same subject across days), we can also include lines that show the trend of each subject by adding group argument in sm_raincloud(). sep_level is an argument to specify the degree of separation among points, boxplots and violin plots. When sep_level = 0, they will all be crowded. When sep_level = 4, they will all be separated from each other. I personally prefer when the boxplot and violin plots are together, but not the points. So I will set it sep_level = 2. sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.4) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) You can also flip the raincloud plot by setting which_side to left. sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.4, which_side = &#39;left&#39;) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) So far the distribution plots (violin plots) have been vertical. We can change their configuration by setting vertical = FALSE. sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.4, which_side = &#39;left&#39;, vertical = FALSE) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) The orientation is not correct, so lets change it by setting which_side = 'right'. sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.4, which_side = &#39;right&#39;, vertical = FALSE) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + xlab(&#39;Day&#39;) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) 4.10 Overriding defaults of smplots themes You can override all the defaults by adding theme() object to your ggplot2 graph. Here is a bar graph. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) Now lets remove the x-axis title Day. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + theme(axis.title.x = element_blank()) Lets customise the graph more by changing the y-axis title and adding a main title. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + theme(axis.title.x = element_blank()) + ylab(&#39;Value&#39;) + ggtitle(&#39;Reading performance in children&#39;) "],["recreating-the-cover-example-figure.html", "Chapter 5 Recreating the Cover Example Figure 5.1 Boxplot and violin plot 5.2 Bar plot and slope chart 5.3 Raincloud plot 5.4 Put all figures together", " Chapter 5 Recreating the Cover Example Figure Load these packages by typing the codes below. library(tidyverse) # it has ggplot2 package library(cowplot) # it allows you to save figures in .png file library(smplot) 5.1 Boxplot and violin plot Upload pre-existing data Upload the data using read_csv(). Then, convert the Day levels into factor to override the alphabetical order. df &lt;- read_csv(&#39;https://raw.githubusercontent.com/smin95/dataviz/master/data.csv&#39;) df$Day &lt;- factor(df$Day, levels = c(&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;)) Plot the boxplot using sm_boxplot() with your preferred aesthetics. Then store the figure into a variable. ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(color = &#39;white&#39;, shape = 21) + scale_fill_manual(values = sm_palette(3)) + ggtitle(&#39;sm_boxplot()&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; boxplot print(boxplot) Plot the violin plot using sm_violin() and store it in a variable. ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;sm_violin()&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;))-&gt; violin print(violin) 5.2 Bar plot and slope chart Generate random data. set.seed(1) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 2) Data &lt;- data.frame(Value = matrix(c(day1,day2),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;), each = length(day1)) df1 &lt;- cbind(Subject, Data, Day) Draw a bar plot using sm_bar() and store it in a variable. ggplot(data = df1, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, point_alpha = 1, bar_alpha = 0.2, bar_fill_color = &#39;black&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + theme(axis.title.x = element_blank()) + ggtitle(&#39;sm_bar()&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; bar print(bar) Draw a slope chart using sm_slope() and store it in a variable. ggplot(data = df1, mapping = aes(x = Day, y = Value, group = Subject, fill = Day)) + sm_slope(labels = c(&#39;Day 1&#39;, &#39;Day 2&#39;), shape = 21, color = &#39;white&#39;, line_alpha = 0.3) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + ggtitle(&#39;sm_slope()&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; slope print(slope) 5.3 Raincloud plot Generate random data. set.seed(2) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) day3 = rnorm(20,6,1.5) day4 = rnorm(20,7,2) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 4) Data &lt;- data.frame(Value = matrix(c(day1,day2,day3,day4),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;, &#39;Day 3&#39;, &#39;Day 4&#39;), each = length(day1)) df2 &lt;- cbind(Subject, Data, Day) Draw a raincloud plot using sm_raincloud() and store it in a variable. sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.2) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) + ggtitle(&#39;sm_raincloud()&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; raincloud print(raincloud) 5.4 Put all figures together First add boxplot, violin plot, bar plot and slope chart together in 2x2 using plot_grid() from the cowplot package. add_four &lt;- plot_grid(boxplot, violin, bar, slope, ncol = 2, nrow = 2, rel_widths = c(1,1,1,1), scale = 0.95) print(add_four) Then, add the raincloud plot below the combined 2x2 figure (add_four). all &lt;- plot_grid(add_four, raincloud, ncol = 1, nrow = 2, rel_widths = c(1,1), rel_heights = c(2,1.05)) print(all) Now save the figure in a png file in your working directory using save_plot() from the cowplot package. save_plot(&quot;sample.png&quot;, tgd, ncol = 2, nrow = 3, base_asp = .95, dpi = 600) The codes only with no discussion df &lt;- read_csv(&#39;https://raw.githubusercontent.com/smin95/dataviz/master/data.csv&#39;) df$Day &lt;- factor(df$Day, levels = c(&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;)) ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_boxplot(color = &#39;white&#39;, shape = 21) + scale_fill_manual(values = sm_palette(3)) + ggtitle(&#39;Boxplot&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; boxplot ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;Violin plot&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;))-&gt; violin set.seed(1) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 2) Data &lt;- data.frame(Value = matrix(c(day1,day2),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;), each = length(day1)) df1 &lt;- cbind(Subject, Data, Day) ggplot(data = df1, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, point_alpha = 1, bar_alpha = 0.2, bar_fill_color = &#39;black&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + theme(axis.title.x = element_blank()) + ggtitle(&#39;Bar plot&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; bar ggplot(data = df1, mapping = aes(x = Day, y = Value, group = Subject, fill = Day)) + sm_slope(labels = c(&#39;Day 1&#39;, &#39;Day 2&#39;), shape = 21, color = &#39;white&#39;, line_alpha = 0.3) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + ggtitle(&#39;Slope chart&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; slope # raincloud plot set.seed(2) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) day3 = rnorm(20,6,1.5) day4 = rnorm(20,7,2) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 4) Data &lt;- data.frame(Value = matrix(c(day1,day2,day3,day4),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;, &#39;Day 3&#39;, &#39;Day 4&#39;), each = length(day1)) df2 &lt;- cbind(Subject, Data, Day) sm_raincloud(data = df2, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.2) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) + ggtitle(&#39;Raincloud plot&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; raincloud add_four &lt;- plot_grid(boxplot, violin, bar, slope, ncol =2, nrow = 2, rel_widths = c(1,1,1,1), scale = 0.95) all &lt;- plot_grid(add_four, raincloud, ncol = 1, nrow = 2, rel_widths = c(1,1), rel_heights = c(2,1.05)) save_plot(&quot;sample.png&quot;, tgd, ncol = 2, nrow = 3, base_asp = .95, dpi = 600) "],["recreating-the-manuscript-figures.html", "Chapter 6 Recreating the Manuscript Figures 6.1 Figure 1 - Correlation plot 6.2 Figure 2 - Bar plot 6.3 Figure 3 - Boxplot 6.4 Figure 4 - Violin plot 6.5 Figure 5 - Slope chart 6.6 Figure 6 - Raincloud plot 6.7 Figure 7 - Case study", " Chapter 6 Recreating the Manuscript Figures Load these packages by typing the codes below. library(tidyverse) # it has ggplot2 package library(cowplot) # it allows you to save figures in .png file library(smplot) 6.1 Figure 1 - Correlation plot corr1 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;, size = 3) + # ggplot2 default ggtitle(&#39;Correlation plot without smplot&#39;) text1 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Base plot only using \\nthe defaults of ggplot2&#39;, x = 3.9, y = 25) corr2 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;, size = 3) + sm_corr_theme() + # smplot correlation theme ggtitle(&#39;Correlation plot with smplot&#39;) text2 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Base plot + sm_corr_theme()&#39;, x = 3.9, y = 29, fontface = 2) + annotate(&#39;text&#39;, x = 3.9, y = 23, parse = TRUE, label = &#39;bold(sm_corr_theme())~\\nprovides~\\na~theme~with&#39;) + annotate(&#39;text&#39;, x = 3.9, y = 20, label = &#39;minimalistic background\\nlarger font\\ncentered title&#39;) corr3 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(shape = 21, fill = sm_color(&#39;green&#39;), color = &#39;white&#39;, size = 3) + sm_corr_theme() + # smplot corr theme + p and r values sm_statCorr(color = sm_color(&#39;green&#39;), corr_method = &#39;spearman&#39;) + ggtitle(&#39;Statistics computed with smplot&#39;) text3 &lt;- ggplot(data = mtcars, mapping = aes(x = drat, y = mpg)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Base plot + sm_corr_theme() +\\nsm_statCorr()&#39;, x = 3.9, y = 30, fontface = 2) + annotate(&#39;text&#39;, x = 3.9, y = 24, parse = TRUE, label = &#39;bold(sm_statCorr())~from~smplot~computes&#39;) + annotate(&#39;text&#39;, x = 3.9, y = 22.6, label = &#39;R and p values from a correlation test.&#39;) + annotate(&#39;text&#39;, x = 3.9, y = 18, label = &#39;\\nIt also prints the best-fit \\nlinear regression line \\nbased on the R value.&#39;) corr_all &lt;- plot_grid(corr1, text1, corr2, text2, corr3, text3, labels = c(&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;, &quot;C&quot;, &quot;&quot;), label_size = 12, ncol = 2, nrow = 3, scale = 0.95) print(corr_all) save_plot(&quot;corr_plots.png&quot;, corr_all, ncol = 2, nrow = 3, base_asp = .95, dpi = 600) 6.2 Figure 2 - Bar plot set.seed(1) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 2) Data &lt;- data.frame(Value = matrix(c(day1,day2),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;), each = length(day1)) df &lt;- cbind(Subject, Data, Day) bar1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + stat_summary(fun = mean, geom = &#39;bar&#39;) + theme(legend.position = &#39;none&#39;) + ggtitle(&#39;Bar plot without smplot&#39;) text1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Bar~plot~using~bold(stat_summary())~from~ggplot2&#39;, x = 1.5, y = 3, parse = TRUE) bar2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, fill = Day)) + sm_bar(shape = 21, color = &#39;white&#39;, bar_fill_color = &#39;gray80&#39;) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + ggtitle(&#39;Bar plot using smplot&#39;) text2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Bar~plot~using~bold(sm_bar())&#39;, x = 1.5, y = 4.5, parse = TRUE) + annotate(&#39;text&#39;, label = &#39;Individual points,\\nlarger font,\\nminimalistic theme\\ncentered title\\nnarrower bar width\\nerror bar&#39;, x = 1.5, y = 1.5) bar_all &lt;- plot_grid(bar1, text1, bar2, text2, labels = c(&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;), label_size = 12, ncol = 2, nrow = 2, scale = 0.95) print(bar_all) save_plot(&quot;bars.png&quot;, bar_all, ncol = 2, nrow = 2, base_asp = .95, dpi = 600) 6.3 Figure 3 - Boxplot df &lt;- read_csv(&#39;https://raw.githubusercontent.com/smin95/dataviz/master/data.csv&#39;) df$Day &lt;- factor(df$Day, levels = c(&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;)) boxplot1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_boxplot() + theme(legend.position = &#39;none&#39;) + ggtitle(&#39;Boxplot without smplot&#39;) text1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Boxplot~using~bold(geom_boxplot())\\n~from~ggplot2&#39;, x = 2, y = 8, parse = TRUE) boxplot2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_boxplot(shape = 16, alpha = 0.4) + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;Boxplot with smplot&#39;) # smplot&#39;s default text2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Boxplot~using~bold(sm_boxplot())&#39;, x = 2, y = 11, parse = TRUE) + annotate(&#39;text&#39;, label = &#39;Individual points,\\nlarger font,\\nminimalistic theme\\ncentered title&#39;, x = 2, y = 5) boxplot_all &lt;- plot_grid(boxplot1, text1, boxplot2, text2, labels = c(&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;), label_size = 12, ncol = 2, nrow = 2, scale = 0.95) print(boxplot_all) save_plot(&quot;boxplots.png&quot;, boxplot_all, ncol = 2, nrow = 2, base_asp = .95, dpi = 600) 6.4 Figure 4 - Violin plot violin1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + geom_violin() + theme(legend.position = &#39;none&#39;) + ggtitle(&#39;Violin plot without smplot&#39;) ## ggplot2 default text1 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Violin~plot~using~bold(geom_violin())\\n~from~ggplot2&#39;, x = 2, y = 8, parse = TRUE) violin2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value, color = Day)) + sm_violin() + scale_color_manual(values = sm_palette(3)) + ggtitle(&#39;Violin plot with smplot&#39;) # smplot default text2 &lt;- ggplot(data = df, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;Violin~plot~using~bold(sm_violin())\\nfrom~smplot&#39;, x = 2, y = 12, parse = TRUE) + annotate(&#39;text&#39;, label = &#39;Individual points,\\nlarger font,\\nminimalistic theme\\ncentered title\\nerror bars&#39;, x = 2, y = 4) violin_all &lt;- plot_grid(violin1, text1, violin2, text2, labels = c(&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;), label_size = 12, ncol = 2, nrow = 2, scale = 0.95) print(violin_all) save_plot(&quot;violins.png&quot;, violin_all, ncol = 2, nrow = 2, base_asp = .95, dpi = 600) 6.5 Figure 5 - Slope chart set.seed(1) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 2) Data &lt;- data.frame(Value = matrix(c(day1,day2),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;), each = length(day1)) df1 &lt;- cbind(Subject, Data, Day) ggplot(data = df1, mapping = aes(x = Day, y = Value, group = Subject, fill = Day)) + sm_slope(labels = c(&#39;Day 1&#39;, &#39;Day 2&#39;), shape = 21, color = &#39;white&#39;, line_alpha = 0.3) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + ggtitle(&#39;A slope chart with 2 x-levels&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; slope_n2 set.seed(2) # generate random data day1 = rnorm(20,0,1) day2 = rnorm(20,5,1) day3 = rnorm(20,6,1.5) day4 = rnorm(20,7,2) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 4) Data &lt;- data.frame(Value = matrix(c(day1,day2,day3,day4),ncol=1)) Day &lt;- rep(c(&#39;Day 1&#39;, &#39;Day 2&#39;, &#39;Day 3&#39;, &#39;Day 4&#39;), each = length(day1)) df2 &lt;- cbind(Subject, Data, Day) ggplot(data = df2, mapping = aes(x = Day, y = Value, group = Subject, fill = Day)) + sm_slope(labels = c(&#39;Day 1&#39;, &#39;Day 2&#39;, &#39;Day 3&#39;, &#39;Day 4&#39;), shape = 21, color = &#39;white&#39;, line_alpha = 0.3) + scale_fill_manual(values = sm_palette(4)) + ggtitle(&#39;sm_slope() with 4 x-levels&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) -&gt; slope_n4 slopes &lt;- plot_grid(slope_n2, slope_n4, labels = c(&quot;A&quot;, &quot;B&quot;), rel_widths = c(1.5,2), label_size = 12, ncol = 2, nrow = 1, scale = 0.95) print(slopes) save_plot(&quot;slopes.png&quot;, slopes, ncol = 2, nrow = 1, base_asp = .95, dpi = 600) 6.6 Figure 6 - Raincloud plot raincloud1 &lt;- sm_raincloud(data = df1, x = Day, y = Value, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 0, line_alpha = 0.2) + scale_x_continuous(limits = c(0.15,2.85), labels = c(&#39;1&#39;, &#39;2&#39;), breaks = c(1,2)) + scale_color_manual(values = rep(&#39;transparent&#39;,2)) + scale_fill_manual(values = sm_palette(2)) + ggtitle(&#39;A raincloud plot with 2 x-levels&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) text1 &lt;- ggplot(data = df1, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;sep_level = 0\\nwhich_side = &quot;right&quot;&#39;, x = 1.5, y = 5, fontface = 2) + annotate(&#39;text&#39;, x = 1.5, y = 2.5, label = &#39;Separation is minimum amongst\\npoints, violin plot and boxplot.\\nThis can be adjusted with&#39;) + annotate(&#39;text&#39;, x = 1.5, y = 1.6, label = &#39;\\n sep_level (0-4).&#39;, fontface = 2) + annotate(&#39;text&#39;, x = 1.5, y = -0.5, label = &#39;The violin plots face to the right.\\nThis can be be changed with&#39;) + annotate(&#39;text&#39;, x = 1.5, y = -1.1, label = &#39;\\n which_side (&quot;right&quot;, &quot;left&quot;, &quot;mixed&quot;).&#39;, fontface = 2) raincloud2 &lt;- sm_raincloud(data = df1, x = Day, y = Value, group = Subject, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.2, which_side = &#39;mixed&#39;) + scale_x_continuous(limits = c(0.15,2.85), labels = c(&#39;1&#39;, &#39;2&#39;), breaks = c(1,2)) + scale_color_manual(values = rep(&#39;transparent&#39;,2)) + scale_fill_manual(values = sm_palette(2)) + ggtitle(&#39;sm_raincloud() with 2 x-levels&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) text2 &lt;- ggplot(data = df1, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;sep_level = 2\\nwhich_side = &quot;mixed&quot;&#39;, x = 1.5, y = 4.7, fontface = 2) + annotate(&#39;text&#39;, x = 1.5, y = 2.8, label = &#39;Default sep_level is set at 2\\n but this can be changed (0-4).&#39;) + annotate(&#39;text&#39;, x = 1.5, y = 1, label = &#39;The violin plots face both to the\\nleft (x=1) and right (x=2).&#39;) + annotate(&#39;text&#39;, x = 1.5, y = -0.6, label = &#39;\\nwhich_side = &quot;mixed&quot; only works when\\nthere are 2 x discrete levels.&#39;, fontface = 2) raincloud3 &lt;- sm_raincloud(data = df1, x = Day, y = Value, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 4, line_alpha = 0.2, which_side = &#39;left&#39;) + scale_x_continuous(limits = c(0.15,2.85), labels = c(&#39;1&#39;, &#39;2&#39;), breaks = c(1,2)) + scale_color_manual(values = rep(&#39;transparent&#39;,2)) + scale_fill_manual(values = sm_palette(2)) + ggtitle(&#39;A raincloud with no overlap&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) text3 &lt;- ggplot(data = df1, mapping = aes(x = Day, y = Value)) + geom_point(color = &#39;white&#39;, fill = &#39;white&#39;) + theme_nothing() + annotate(&#39;text&#39;, label = &#39;sep_level = 4\\nwhich_side = &quot;left&quot;&#39;, x = 1.5, y = 3.5, fontface = 2) + annotate(&#39;text&#39;, x = 1.5, y = 1.5, label = &#39;The violin plots face to the left.&#39;) raincloud_2x_all &lt;- plot_grid(raincloud1, text1, raincloud2, text2, raincloud3, text3, labels = c(&quot;A&quot;, &quot;&quot;, &quot;B&quot;, &quot;&quot;, &quot;C&quot;, &quot;&quot;), label_size = 12, ncol = 2, nrow = 3, scale = 0.95) raincloud4 &lt;- sm_raincloud(data = df2, x = Day, y = Value, boxplot_alpha = 0.5, color = &#39;white&#39;, shape = 21, sep_level = 2, line_alpha = 0.2) + scale_x_continuous(limits = c(0.25,4.75), labels = c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;), breaks = c(1,2,3,4)) + scale_color_manual(values = rep(&#39;transparent&#39;,4)) + scale_fill_manual(values = sm_palette(4)) + ggtitle(&#39;Four discrete levels of x, sep_level = 2, which_side = &quot;right&quot;&#39;) + xlab(&#39;Day&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) raincloud_all &lt;- plot_grid(raincloud_2x_all, raincloud4, labels = c(&quot;&quot;,&quot;D&quot;), label_size = 12, ncol = 1, nrow = 2, scale = 0.95, rel_heights = c(7.5,2.5)) print(raincloud_all) save_plot(&quot;rainclouds.png&quot;, raincloud_all, ncol = 2, nrow = 4, base_asp = .95, dpi = 600) 6.7 Figure 7 - Case study set.seed(11) # generate random data method1 = c(rnorm(19,0,1),2.5) method2 = c(rnorm(19,0,1),2.5) Subject &lt;- rep(paste0(&#39;S&#39;,seq(1:20)), 2) Data &lt;- data.frame(Value = matrix(c(method1,method2),ncol=1)) Method &lt;- rep(c(&#39;Method 1&#39;, &#39;Method 2&#39;), each = length(method1)) df &lt;- cbind(Subject, Data, Method) # slope chart ggplot(data = df, mapping = aes(x = Method, y = Value, group = Subject, fill = Method)) + sm_slope(labels = c(&#39;Method 1&#39;, &#39;Method 2&#39;), shape = 21, color = &#39;white&#39;, line_alpha = 0.3) + scale_fill_manual(values = sm_color(&#39;blue&#39;,&#39;orange&#39;)) + ggtitle(&#39;Slope chart&#39;) + theme(plot.title = element_text(face=&quot;bold&quot;)) + ylab(&#39;Gene expression level&#39;) + annotate(&#39;text&#39;, x = 1.5, y = 2, label = &#39;sm_slope()&#39;) -&gt; slope # correlation plot df3 &lt;- data.frame(first = method1, second = method2) corr_plot &lt;- ggplot(data = df3, mapping = aes(x = first, y = second)) + geom_point(shape = 21, fill = sm_color(&#39;blue&#39;), color = &#39;white&#39;, size = 3) + sm_corr_theme(borders = FALSE) + scale_y_continuous(limits = c(-2.5,2.5)) + scale_x_continuous(limits = c(-2.5,2.5)) + sm_statCorr(color = sm_color(&#39;blue&#39;), corr_method = &#39;pearson&#39;, label_x = -2.2, label_y = 2.3) + ggtitle(&#39;Correlation plot&#39;) + xlab(&#39;Method 1&#39;) + ylab(&#39;Method 2&#39;) + annotate(&#39;text&#39;, x = 0, y = -2.3, label = &#39;sm_corr_theme() + sm_statCorr()&#39;) # BA plot res &lt;- sm_statBlandAlt(df3$first,df3$second) ba_plot &lt;- sm_bland_altman(df3$first, df3$second, shape = 21, color = &#39;white&#39;, fill = sm_color(&#39;blue&#39;)) + scale_y_continuous(limits = c(-5,5)) + scale_x_continuous(limits = c(-2,5)) + annotate(&#39;text&#39;, label = &#39;Mean&#39;, x = 4.3, y = res$mean_diff + 0.4) + annotate(&#39;text&#39;, label = signif(res$mean_diff,3), x = 4.3, y = res$mean_diff - 0.4) + annotate(&#39;text&#39;, label = &#39;Upper limit&#39;, x = 4.3, y = res$upper_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$upper_limit,3), x = 4.3, y = res$upper_limit - 0.4) + annotate(&#39;text&#39;, label = &#39;Lower limit&#39;, x = 4.3, y = res$lower_limit + 0.4) + annotate(&#39;text&#39;, label = signif(res$lower_limit,3), x = 4.3, y = res$lower_limit - 0.4) + ggtitle(&#39;Bland-Altman plot&#39;) + annotate(&#39;text&#39;, x = 1.5, y = -4, label = &#39;sm_statBlandAlt() + \\nsm_bland_altman()&#39;) case_study &lt;- plot_grid(slope, corr_plot, ba_plot, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), hjust = -4, # horizontal position of ABC labels label_size = 12, ncol = 3, nrow = 1, scale = 0.95) print(case_study) save_plot(&quot;case_study.png&quot;, case_study, ncol = 3, nrow = 1, base_asp = .95, dpi = 600) "]]
