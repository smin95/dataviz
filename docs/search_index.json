[["plotting-the-contrast-sensitivity-function.html", "Chapter 9 Plotting the Contrast Sensitivity Function 9.1 Brief Introduction 9.2 Data Visualization 9.3 Facetting the Contrast Sensitivity Functions", " Chapter 9 Plotting the Contrast Sensitivity Function In this section, we will plot the contrast sensitivity function using the smCSF package. I will complement it with smplot for aesthetics. We will use data of achromatic contrast sensitivity from 51 normal observers from this paper (a subset of the entire dataset): Kim, Y. J., Reynaud, A., Hess, R. F., &amp; Mullen, K. T. (2017). A normative data set for the clinical assessment of achromatic and chromatic contrast sensitivity using a qCSF approach. Investigative ophthalmology &amp; visual science, 58(9), 3628-3636. Luckily, the data are publicly available. I have reorganized the data so that we could easily use them in the form of a data frame. Lets load the data from online. library(tidyverse) ## -- Attaching packages --------------------------------- tidyverse 1.3.1 -- ## v ggplot2 3.3.5 v purrr 0.3.4 ## v tibble 3.1.6 v dplyr 1.0.8 ## v tidyr 1.2.0 v stringr 1.4.0 ## v readr 2.1.2 v forcats 0.5.1 ## -- Conflicts ------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(smplot) ## Updated tutorial for smplot: smin95.github.io/dataviz/ library(smCSF) ## Updated tutorial for smCSF: smin95.github.io/dataviz/ ACh &lt;- read_csv(&#39;https://www.smin95.com/data_ACh.csv&#39;) ## Rows: 1224 Columns: 4 ## -- Column specification -------------------------------------------------- ## Delimiter: &quot;,&quot; ## chr (1): Subject ## dbl (3): Repetition, SpatialFreq, Sensitivity ## ## i Use `spec()` to retrieve the full column specification for this data. ## i Specify the column types or set `show_col_types = FALSE` to quiet this message. head(ACh) ## # A tibble: 6 x 4 ## Subject Repetition SpatialFreq Sensitivity ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 S1 1 0.25 23.8 ## 2 S2 1 0.25 18.0 ## 3 S3 1 0.25 14.2 ## 4 S4 1 0.25 5.14 ## 5 S5 1 0.25 16.0 ## 6 S6 1 0.25 10.9 There are four columns in this data frame: First, Subject refers to each participant. There are 51 participants total in the .csv file. Next, Repetition refers to each repetition of the measurement The participants performed two repetitions of the contrast sensitivity measurement. SpatialFreq refers to spatial frequency of the stimuli that were shown to test the observers contrast sensitivity. There are a total of 12 spatial frequencies. The Sensitivity column refers to the linear values of the contrast sensitivity. 9.1 Brief Introduction The contrast sensitivity function (CSF) how the observer is sensitive to an image. This image could be large (low spatial frequency) or small (high spatal frequency). To obtain the CSF, the measurement test must measure the threshold. Threshold refers to the difference in stimulus magnitude between the states of presence and absence. If the observer can just barely discriminate between these two states of the visual stimulus, this can be described as the threshold for detection. 9.2 Data Visualization First, lets compute the average, standard errors and standard deviation using the dataset. It is recommended that the reader has read Chapters 5 and 6 already. Understanding of summarise(), filter(), mutate() and %&gt;% is assumed. The code below reorganizes the ACh dataset so that instead of containing the data of each subject, it now contains the averaged data across Repetition and SpatialFreq as well as their standard errors and standard deviations. We use mean() to compute the mean, sm_stdErr() the standard error, and sd() the standard deviation. ACh_avg &lt;- ACh %&gt;% group_by(Repetition, SpatialFreq) %&gt;% summarise(avgSens = mean(Sensitivity), stdErrSens = sm_stdErr(Sensitivity), stdDevSens = sd(Sensitivity)) ## `summarise()` has grouped output by &#39;Repetition&#39;. You can override using ## the `.groups` argument. ACh_avg ## # A tibble: 24 x 5 ## # Groups: Repetition [2] ## Repetition SpatialFreq avgSens stdErrSens stdDevSens ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.25 12.6 0.743 5.31 ## 2 1 0.35 14.7 0.777 5.55 ## 3 1 0.49 18.6 0.993 7.09 ## 4 1 0.68 23.7 1.22 8.71 ## 5 1 0.94 28.7 1.36 9.68 ## 6 1 1.31 32.0 1.40 9.99 ## 7 1 1.83 32.4 1.43 10.2 ## 8 1 2.54 29.6 1.39 9.93 ## 9 1 3.54 24.3 1.22 8.70 ## 10 1 4.93 18.1 0.960 6.85 ## # ... with 14 more rows Lets create a variable that stores the data for each Repetition. Before we do that, however, it is important that we convert the data type of the Repetition column from &lt;dbl&gt; to &lt;fct&gt;, which refers from double to factor. Double refers to continuous data, whereas factor refers to categorical data. ACh_avg$Repetition &lt;- factor(ACh_avg$Repetition) # factor ACh_avg1 &lt;- ACh_avg %&gt;% filter(Repetition == 1) # repetition 1 ACh_avg2 &lt;- ACh_avg %&gt;% filter(Repetition == 2) # repetition 2 Lets now plot the data for each repetition using ggplot2. Understanding of Chapters 1-4 is assumed. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + geom_point() + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 1 (n=51)&#39;) So far, this graph does not show the contrast sensitivity function, which has a rotund shape. Instead, if we connect the points, we get this plot instead. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + geom_point() + geom_line() + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 1 (n=51)&#39;) The function is still not a smooth, rotund shape. This is because it is standard to plot the contrast sensitivity function in log10 scales in both x and y axes. The code below shows the plot in the log scale. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + geom_point() + geom_line() + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 1 (n=51)&#39;) + scale_x_continuous(trans = &#39;log10&#39;) + scale_y_continuous(trans = &#39;log10&#39;) This plot shows the averaged sensitivity for each spatial frequency during the first repetition. However, the contrast sensitivity function is still missing because this plot instead shows the plot that is connected between a pair of the points. To plot the contrast sensitivity function with the data, sm_CSF() is required. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF() Notice that even if the data frame contains data in linear units, the plotted data from sm_CSF() are in log10 scales. It shows a nice, rotund shape that is typical of the contrast sensitivity function. The function can also plot the linear curve by setting sm_CSF(logXY = FALSE). The default is sm_CSF(logXY = TRUE). ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF(logXY = FALSE) Now lets plot a prettier contrast sensitivity function. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF(color = sm_color(&#39;wine&#39;)) + geom_point(color = sm_color(&#39;darkred&#39;), size = 3) + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 1 (n=51)&#39;) We can also plot the data using ACh_avg2, which contains data from the second repetition rather than first. ACh_avg2 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF(color = sm_color(&#39;lightgreen&#39;)) + geom_point(color = sm_color(&#39;viridian&#39;), size = 3) + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 2 (n=51)&#39;) Notice that sm_CSF() is written first because the curve has to appear before the points (geom_point()); else, the points will be covered by the CSF curve. This example is shown below. ACh_avg2 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + geom_point(color = sm_color(&#39;viridian&#39;), size = 3) + sm_CSF(color = sm_color(&#39;lightgreen&#39;)) + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 2 (n=51)&#39;) The curve appears later in this plot, so it covers some overlapping points. smCSF also offers a function that fill the area of the CSF curve. This function is sm_areaCSF(). The default is set to plot the area in log10 scales, sm_areaCSF(logXY = TRUE). ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_areaCSF() + sm_CSF() To plot the linear CSF and its area, logXY = FALSE has to be set FALSE in both sm_areaCSF() and sm_CSF(). The functions of smCSF have defaults logXY = TRUE, therefore, it is recommended that the user uploads a data frame that contains the linear data of spatial frequencies and contrast sensitivities. The functions then will convert them into log scale by default. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_areaCSF(logXY = FALSE) + sm_CSF(logXY = FALSE) We can make the area plot prettier. ACh_avg2 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_areaCSF(fill = sm_color(&#39;lightgreen&#39;), alpha = 0.5) + sm_CSF(color = sm_color(&#39;viridian&#39;)) + sm_hgrid() + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 2 (n=51)&#39;) + scale_y_log10(limits = c(1,100)) + annotate(&#39;text&#39;, x = 0.9, y = 1.3, label = &#39;Area under Log CSF&#39;) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. You might get a warning that says Scale for 'y' is already present. Adding another scale for 'y', which will replace the existing scale. You can ignore this warning and not be worried about it. This is because we used the function scale_y_log10() on top of sm_CSF(), which actually calls forth the function scale_y_continuous() to convert the plot into log scales. Hence, there are two functions that serve the same purpose here, so the warning message is printed. The smCSF package also offers a function that draws a ribbon shade to denote standard error or standard deviation. This function works exactly the same as geom_ribbon(). It requires the uses to specify ymin and ymax. The example below plots standard deviation using sm_ribbonCSF(), where ymin = avgSens - stdDevSens and ymax = avgSens + stdDevSens. As before, its default is logXY = TRUE. Therefore, even if ACh_avg2 contains data in linear units, the ribbon shade that is generated by sm_ribbonCSF() will be in log unit. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens)) + sm_CSF() + scale_y_log10(limits = c(1,100)) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. Lets make the plot prettier using smplot. ACh_avg1 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), fill = sm_color(&#39;wine&#39;), alpha = 0.4) + sm_CSF(color = sm_color(&#39;darkred&#39;)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Repetition 1 (n=51)&#39;) + sm_hgrid() + scale_y_log10(limits = c(1,100)) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. You can also shade standard error instead, but the ribbon is barely visible. ACh_avg2 %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_ribbonCSF(aes(ymin = avgSens - stdErrSens, ymax = avgSens + stdErrSens)) + sm_CSF() + scale_y_log10(limits = c(1,100)) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. As practice, lets plot the averaged data across all repetitions. ACh_avg_final &lt;- ACh %&gt;% group_by(SpatialFreq) %&gt;% summarise(avgSens = mean(Sensitivity), stdErrSens = sm_stdErr(Sensitivity), stdDevSens = sd(Sensitivity)) head(ACh_avg_final) ## # A tibble: 6 x 4 ## SpatialFreq avgSens stdErrSens stdDevSens ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.25 13.2 0.536 5.41 ## 2 0.35 15.2 0.568 5.74 ## 3 0.49 19.1 0.698 7.05 ## 4 0.68 24.3 0.836 8.44 ## 5 0.94 29.4 0.938 9.48 ## 6 1.31 33.0 0.977 9.87 Here is the new data frame ACh_avg_final. ACh_avg_final %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), fill = sm_color(&#39;skyblue&#39;), alpha = 0.25) + sm_CSF(color = sm_color(&#39;blue&#39;), alpha = 0.4) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + ggtitle(&#39;Contrast Sensitivity (n=51)&#39;) + sm_hgrid() + geom_point(color = sm_color(&#39;blue&#39;), size = 2.5) + scale_y_log10(limits = c(1,100)) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. The standard deviation seems to be still broad. 9.3 Facetting the Contrast Sensitivity Functions To facet means to split the plot into multiple plots based on a categorical variable (i.e., factor). We will facet the contrast sensitivity function plot above (the blue curve) into two panels based on two repetitions (red and green below). ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. To facet the plot, you need to have a data frame that has data with a column that specifies the categorical variable. For instance, lets look at the data frame ACh_avg. ACh_avg ## # A tibble: 24 x 5 ## # Groups: Repetition [2] ## Repetition SpatialFreq avgSens stdErrSens stdDevSens ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.25 12.6 0.743 5.31 ## 2 1 0.35 14.7 0.777 5.55 ## 3 1 0.49 18.6 0.993 7.09 ## 4 1 0.68 23.7 1.22 8.71 ## 5 1 0.94 28.7 1.36 9.68 ## 6 1 1.31 32.0 1.40 9.99 ## 7 1 1.83 32.4 1.43 10.2 ## 8 1 2.54 29.6 1.39 9.93 ## 9 1 3.54 24.3 1.22 8.70 ## 10 1 4.93 18.1 0.960 6.85 ## # ... with 14 more rows We see that the first column of Ach_avg has a column named Repetition which stores whether the given data are from the first or second repetition. To see all the unique levels of Repetition, we can use the function unique(). unique(ACh_avg$Repetition) ## [1] 1 2 ## Levels: 1 2 To facet a plot using ggplot2, the function facet_wrap() has to be used. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF() + facet_wrap(~ Repetition) The argument inside facet_wrap has to include the tilde (~). The right side the tilde (~) should be the name of the categorical variable by which you wish to facet the plot. If the variable however happens to be continuous, facet_wrap() would not work properly. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens)) + sm_CSF() + facet_wrap(~ stdErrSens) However, I do not often use facet_wrap() because the plot often ends up not being pretty. Lets try to make it prettier. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens, group = Repetition, color = Repetition, fill = Repetition)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), alpha = 0.4) + sm_CSF(alpha = 0.4) + sm_hgrid() + geom_point(size = 2.5) + scale_fill_manual(values = sm_color(&#39;wine&#39;,&#39;lightgreen&#39;)) + scale_color_manual(values = sm_color(&#39;darkred&#39;,&#39;viridian&#39;)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + facet_wrap(~ Repetition) + scale_y_log10(limits = c(1,100)) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. Personally, I do not like the grey-filled header of each panel. Since I personally will find myself repeatedly bypassing the default grey color into a color of my choice, I have created the function myself sm_facet_header() as part of the smCSF package. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens, group = Repetition, color = Repetition, fill = Repetition)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), alpha = 0.4) + sm_CSF(alpha = 0.4) + sm_hgrid() + geom_point(size = 2.5) + scale_fill_manual(values = sm_color(&#39;wine&#39;,&#39;lightgreen&#39;)) + scale_color_manual(values = sm_color(&#39;darkred&#39;,&#39;viridian&#39;)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + facet_wrap(~ Repetition) + scale_y_log10(limits = c(1,100)) + sm_facet_header() ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. Now the title of each plot has been bolded and the filled color is white. I personally think that this plot is a lot cleaner than the default one. Next, I wish to change the titles of each panel because 1 and 2 are not descriptive. To do so, we need to use the argument labeller within facet_wrap() to specify the title of each panel. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens, group = Repetition, color = Repetition, fill = Repetition)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), alpha = 0.4) + sm_CSF(alpha = 0.4) + sm_hgrid() + geom_point(size = 2.5) + scale_fill_manual(values = sm_color(&#39;wine&#39;,&#39;lightgreen&#39;)) + scale_color_manual(values = sm_color(&#39;darkred&#39;,&#39;viridian&#39;)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + facet_wrap(~ Repetition, labeller = as_labeller(c(&#39;1&#39; = &#39;Repetition 1&#39;, &#39;2&#39; = &#39;Repetition 2&#39;))) + scale_y_log10(limits = c(1,100)) + sm_facet_header(font_size=11) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. We use the function as_labeller() as part of the argument labeller() inside facet_wrap() to specify that factor level 1 should be shown as Repetition 1 and 2 as Repetition 2. We can also change the number of rows and columns using facet_wrap(). Lets make a data frame that has 4 repetitions instead of 2. set.seed(1) spatFreqNum &lt;- length(unique(ACh_avg$SpatialFreq)) ACh_avg_4rep &lt;- rbind(ACh_avg,ACh_avg) ACh_avg_4rep$Repetition &lt;- rep(1:4,each=spatFreqNum) ACh_avg_4rep[25:nrow(ACh_avg_4rep), 3:5] &lt;- ACh_avg_4rep[25:nrow(ACh_avg_4rep), 3:5] + round(rnorm(24),1) ACh_avg_4rep$Repetition &lt;- factor(ACh_avg_4rep$Repetition) We can specify the number of columns (ex. ncol = 2) and rows (ex. nrow = 2) inside the function facet_wrap(), as shown in the example below. ACh_avg_4rep %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens, group = Repetition, color = Repetition, fill = Repetition, alpha = Repetition)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens)) + sm_CSF(alpha = 0.4) + sm_hgrid() + geom_point(alpha = 1, size = 2.5) + scale_fill_manual(values = sm_color(&#39;wine&#39;,&#39;lightgreen&#39;,&#39;yelloworange&#39;, &#39;crimson&#39;)) + scale_color_manual(values = sm_color(&#39;darkred&#39;,&#39;viridian&#39;, &#39;orange&#39;,&#39;red&#39;)) + scale_alpha_manual(values = c(0.4,0.4,0.3,0.1)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + facet_wrap(~ Repetition, nrow=2, ncol=2, labeller = as_labeller(c(&#39;1&#39; = &#39;Repetition 1&#39;, &#39;2&#39; = &#39;Repetition 2&#39;, &#39;3&#39; = &#39;Repetition 3&#39;, &#39;4&#39; = &#39;Repetition 4&#39;))) + scale_y_log10(limits = c(1,100)) + sm_facet_header(font_size=11) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. Notice that when facet_wrap() is used, there is no need to create variable for each plot like we have done in Chapter 5 and use sm_common_axis(). The preference can vary depending on the user. Rather than using facet_wrap(), however, I still prefer to store each plot so that I can have freedom to decide where to place each panel wherever I want . Another issue with plotting each contrast sensitivity function per panel is that it is visually difficult to compare whether the functions between the panels are different. One way to overcome this problem is to plot all the plots together. In this case, legend is necessary, which can be generated using sm_hgrid(legends = TRUE). Lets use the data frame ACh_avg which has two levels in the Repetition column. ACh_avg %&gt;% ggplot(aes(x = SpatialFreq, y = avgSens, group = Repetition, color = Repetition, fill = Repetition)) + sm_ribbonCSF(aes(ymin = avgSens - stdDevSens, ymax = avgSens + stdDevSens), alpha = 0.2) + sm_CSF(alpha = 0.4) + sm_hgrid(legends = T) + scale_fill_manual(values = sm_color(&#39;wine&#39;,&#39;lightgreen&#39;)) + scale_color_manual(values = sm_color(&#39;darkred&#39;,&#39;viridian&#39;)) + xlab(&#39;Spatial frequency (c/deg)&#39;) + ylab(&#39;Averaged sensitivity&#39;) + scale_y_log10(limits = c(1,100)) + theme(legend.position = c(0.8,0.2)) + ggtitle(&#39;Achromatic CSF (n=51)&#39;) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which ## will replace the existing scale. We see that these two curves are nearly identical, except that the green curve is uniformly higher than the red curve. In the next chapter, we will discuss about some techniques on how to analyze contrast sensitivity data. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
