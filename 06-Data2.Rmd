---
output: html_document
chapter: Data analysis 
editor_options:
  chunk_output_type: console
---

# Data Analysis Part 2

<<<<<<< HEAD
This chapter is in progress (unfinished).

=======
>>>>>>> 6c43d5019c8f3505d2a09dff2883e5b245fcd763
In this chapter, we will continue to use data from this paper:

**Seung Hyun Min, Alex S. Baldwin and Robert F. Hess. Ocular dominance plasticity: A binocular combination task finds no cumulative effect with repeated patching (2019). Vision Research, 161, 36-42.**

In Chapter 5 of the online guide, we only dealt with data from Days 1 and 5. In this chapter, we will use data from Days 1, 2, 3, 4 and 5. The PDF copy of the paper can be accessed [here](https://www.smin95.com/pubs/min2019.pdf). 

Let's begin by loading the `tidyverse` library and uploading the csv file `min2019b.csv` using `read_csv()` from the `tidyverse` package.

`head()` returns the first 6 rows of the data frame. `tail()` returns the last 6 rows of the data frame. 

```{r}
library(tidyverse)
<<<<<<< HEAD
library(smplot)
library(cowplot)
df <- read_csv('https://www.smin95.com/min2019b.csv') 
=======
df <- read_csv('min2019b.csv') 
>>>>>>> 6c43d5019c8f3505d2a09dff2883e5b245fcd763
head(df)
```

`unique()` returns unique values in the data set. Let's see how many unique values there are in the `Day` column of the data set. A column can be extracted by using `$`. 

```{r}
df$Day <- factor(df$Day)
unique(df$Day)
```

Notice that there are now five different days in the data set. 

As previously mentioned, there are four columns in this data frame:

- First, `Subject` refers to each participant. There are 10 participants total. 
- Next, `Day` refers to the day of testing. The participants were tested on Days 1, 2, 3, 4 and 5, ad we will using all data.

- `Time` refers to the number of minutes after an experimental manipulation (ex. monocular deprivation). These are 0, 3, 6, 12, 24 and 48 minutes, but in the data frame, it says 0, 1, 2, 3, 4 and 5; we will change the labels manually. 

- The `Cbratio` column refers to the actual data that will be used for
data analysis.

## Pipe `%>%`

Let's plot data from Day 1 only. 

To do so, we will need to first filter for data from Day 1 using `filter()`, compute the average and standard error across subjects using `summarise()` and `sm_stdErr()`, and save the changed
format of the dataframe into a new variable using `<-` or `->`. 

```{r}
df_day1 <- filter(df, Day == 1)
by_time_day1 <- group_by(df, Time)
avg_day1 <- summarise(by_time_day1, Average = mean(Cbratio),
          StdError = sm_stdErr(Cbratio))

```

The steps above can be simplified by using pipe `%>%` as shown below.

```{r}
avg_day1 <- df %>% filter(Day == 1) %>% group_by(Time) %>%
  summarise(Average = mean(Cbratio),
          StdError = sm_stdErr(Cbratio))
```

Pipe `%>%` is extremely useful because it allows you to write codes
that are easier to understand. Notice that if you use `%>%`, the input
does not have to written because the input is actually the code that is written just before. For example:

```{r}
df %>% filter(Day == 1)
```

```{r}
filter(df, Day == 1)
```

These two are identical. But notice that if you do not use pipe,
you might have to save the intermediate variables (such as `df_day1` and `by_time_day1`) multiple times, which can be tedious. Notice that when pipe `%>%` is used, the need to save these variables disappears.

I will use `%>%` from now on due to my personal preference.

## Area under a curve

Let's use the data set `avg_day1` to plot data only from Day 1.

<<<<<<< HEAD
```{r, fig.width = 3.65, fig.height = 3.65, warning = F}
=======
```{r}
>>>>>>> 6c43d5019c8f3505d2a09dff2883e5b245fcd763
avg_day1 %>% ggplot(aes(x = Time, y = Average)) +
  geom_area(fill = sm_color('skyblue'), alpha = 0.4) +
   geom_point(size = 4.5, color = sm_color('skyblue')) +
  geom_line(size = 1, color = sm_color('skyblue')) +
  geom_errorbar(aes(ymin = Average - StdError, ymax = Average + StdError), size = .75, width = .05, color = sm_color('skyblue')) +
  scale_x_continuous(breaks = unique(df$Time), 
                     labels = c("0", "3", "6", "12", "24", "48")) +
  sm_hgrid(legends = FALSE) +
  ggtitle("Day 1") +
  xlab("Minutes after monocular deprivation") +
  ylab("\u0394 Contrast balance ratio (dB)") 
```

One way to show data is to calculate the area under a curve (as shown by the colored area) in the figure above. Area under a curve is useful because it reduces a number of data points (6 in this case due to 6 time points) into one. In our context, a large area under a curve represents a large change in contrast balance ratio over time. In short, it captures both the magnitude and longevity of the effect.

Let's calculate area under a curve for each subject and day across 0 to 48 minutes in the x-axis (minutes after monocular deprivation) using `sm_auc()`.

```{r}
x <- c(0,3,6,12,24,48)
```

On the x-axis of the graph, there are six time points. You will need to store these values in a new variable, which I will call `x` here because it represents the x-axis. Instead of manually writing them down, you could extract the unique number of `Time` from the data frame.

```{r}
x <- unique(df$Time) # this is my preferred way
```

Now let's filter for one subject's data (subject `b`) on Day 1 using `filter()` and pipe `%>%`.

```{r}
subj_b_day1 <- df %>% filter(Day == 1 & Subject == 'b')
subj_b_day1
```

<<<<<<< HEAD
```{r, fig.width = 3.65, fig.height = 3.65, warning = F}
=======
```{r}
>>>>>>> 6c43d5019c8f3505d2a09dff2883e5b245fcd763
subj_b_day1 %>% ggplot(aes(x = Time, y = Cbratio)) +
  geom_area(fill = sm_color('skyblue'), alpha = 0.4) +
   geom_point(size = 4.5, color = sm_color('skyblue')) +
  geom_line(size = 1, color = sm_color('skyblue')) +
  scale_x_continuous(breaks = unique(df$Time), 
                     labels = c("0", "3", "6", "12", "24", "48")) +
  sm_hgrid(legends = FALSE) +
  ggtitle("Day 1, Subject b") +
  xlab("Minutes after monocular deprivation") +
  ylab("\u0394 Contrast balance ratio (dB)") 
```

The variable `subj_b_day1` now stores the data of subject `b` on Day 1. Now let's calculate the area under a curve (AUC) from `subj_b_day1` using `sm_auc()`.

`sm_auc()` calculates the AUC using the trapezoid method. It has two arguments:
- The first argument is the x point. In this case, it is the minutes after monocular deprivation (0, 3, 6, 12, 24 and 48). If this argument is left empty, it will use 0, 1, 2, 3 etc as default. For more information, please type `?sm_auc` in the command console.
- The second argument is the data, which is shown by the y-axis in the blue graph. In this case, it is the change of contrast balance ratio (dB). These values can be extracted from `subj_b_day1` using `$`.

```{r}
sm_auc(x, subj_b_day1$Cbratio)
```

The AUC equals 60.53. This shows that for subject `b`, the effect is large and long-lasting. 

<<<<<<< HEAD
Now let's visualize the data of subject `b` from Day 2. 

```{r, fig.width = 3.65, fig.height = 3.65, warning = F}
subj_b_day2 <- df %>% filter(Day == 2 & Subject == 'b')

subj_b_day2 %>% ggplot(aes(x = Time, y = Cbratio)) +
  geom_area(fill = sm_color('yelloworange'), alpha = 0.4) +
   geom_point(size = 4.5, color = sm_color('yelloworange')) +
  geom_line(size = 1, color = sm_color('yelloworange')) +
  scale_x_continuous(breaks = unique(df$Time), 
                     labels = c("0", "3", "6", "12", "24", "48")) +
  sm_hgrid(legends = FALSE) +
  ggtitle("Day 2, Subject b") +
  xlab("Minutes after monocular deprivation") +
  ylab("\u0394 Contrast balance ratio (dB)") 
```

Now, let's calculate the AUC for subject `b` from Day 2. 

```{r}
sm_auc(x, subj_b_day2$Cbratio)
```

The AUC equals 80.38. In the case of subject `b`, the effect seems to have increased on Day 2 relative to Day 1. How do we know if there is a statistically significant difference across five days? We will cover some more statistics later in this chapter.

So far,we have 9 more subjects across five days and subject `b` from three other days. This will require us to compute 48 more AUCs total. This process is rater repetitive. Should we manually compute AUC for each one? Luckily, the answer is no. Let's use `sm_auc_list()`.

```{r}
sm_auc_list(subjects = 'Subject', conditions = 'Day', 
            x = 'Time', values = 'Cbratio',
            data = df)
```

`sm_auc_list()` creates a new data frame with AUC for each subject and condition (in this case, Day). It has five arguments:

- `subjects` = this argument requires the name of the column of the data frame that contains subjects. It must strings, ex. `'Subject'`, not `Subject`.
- `conditions` = this argument requires name of the column of the data frame that contains each condition. In our example, the condition is the day. It must strings, ex. `'Day'`, not `Day`.
- `x` = this argument requires the name of the column of the data frame that contains the x-axis points from which the AUC can be calculated. In our case, these are 0, 3, 6, 12, 24 minutes. It must  strings, ex. `'Time'`, not `Time`.
- `values` = this argument requires the name of the column of the data frame that contains the actual data, which are the y-axis points from which the AUC can be calculated. In our case, it is the change in contrast balance ratio. It must strings, ex. `'Cbratio'`, not `Cbratio`.
- `data` = this argument requires the variable that stores the data frame. In our case, it is `df`.

We can store the results from `sm_auc_list()` into a new variable. I will call the new variable `auc_df`.

```{r}
auc_df <- sm_auc_list(subjects = 'Subject', conditions = 'Day', 
            x = 'Time', values = 'Cbratio',
            data = df)
```

Now we can plot the AUCs using `sm_bar()`, `sm_boxplot` etc. Let's have a try.

Here is a bar graph showing `auc_df`'s data. This figure is similar to Figure 3E in the original paper (Min, Baldwin and Hess, 2019).

- re: means relative. The data are the differences 

```{r, fig.width = 3.65, fig.height = 3.65, warning = F}
auc_df %>% ggplot(aes(x = Day, y = AUC_Cbratio, fill = Day)) +
   sm_bar(shape = 21, color = 'white', 
          bar_fill_color = 'gray80',
          point_alpha = 1) +
  scale_fill_manual(values = sm_palette(5)) +
  ggtitle('\u0394 AUC re: Each day\'s baseline')
```

Here is a box plot showing `auc_df`'s data. 

```{r, fig.width = 3.65, fig.height = 3.65, warning = F}
auc_df %>% ggplot(mapping = aes(x = Day, y = AUC_Cbratio, color = Day)) +
  sm_boxplot(alpha = 0.6) + 
  scale_color_manual(values = sm_palette(5)) +
  ggtitle('\u0394 AUC re: Each day\'s baseline')
=======
Now, we have 9 more subjects across five days and subject `b` from four other days. This will require us to compute 49 more AUCs total. This process is repetitive. Should we manually compute AUC for each one? Luckily, the answer is no. Let's use `sm_auc_list()`.

```{r}
sm_auc_list(df$Subject, df$Day, df$Time, df$Cbratio)
>>>>>>> 6c43d5019c8f3505d2a09dff2883e5b245fcd763
```